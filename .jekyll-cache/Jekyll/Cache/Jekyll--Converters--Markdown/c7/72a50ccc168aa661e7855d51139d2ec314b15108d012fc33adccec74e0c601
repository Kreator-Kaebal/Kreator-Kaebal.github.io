I"<p>파이썬 멀티프로세싱 풀을 알아보자
<!--excerpt--></p>
<h2 id="지난-이야기">지난 이야기</h2>
<p>지난 시간에는 파이썬 멀티프로세싱 중 프로세스(Process)를 이야기했다.<br />
이번에는 멀티프로세싱의 또다른 방법인 풀(Pool)을 설명하겠다.</p>
<h2 id="pool">Pool</h2>
<ul>
  <li>풀은 스타크래프트의 <em>스포닝 풀</em>을 생각하면 된다.
    <ul>
      <li>산란못을 지으면 부화장에서 저글링을 생성할 수 있다. 부화장을 많이 지을수록 더 많은 저글링이 생성된다.</li>
      <li>여기서 <em>산란못을 풀 객체, 부화장을 프로세스<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup>, 저글링 생성 명령을 함수, 부화장의 애벌레 개수를 함수 인자, 저글링을 함수 리턴값</em>이라 보겠다.
        <ul>
          <li>산란못을 지은 뒤 부화장들에게 저글링을 계속 생성하라고 명령을 내린다. 쉽게 말해서 컨트롤+s+z 무한클릭</li>
          <li>부화장들은 자신이 가지고 있는 애벌레 개수만큼 저글링을 생산할 것이다. 만일 애벌레가 없으면 명령을 받지 않다가, 애벌레가 생기면 즉시 명령을 받아들여 저글링을 생산한다.</li>
        </ul>
      </li>
      <li>산란못만 있는 군락지에서는 저글링을 생산할 수 있지만, 히드라는 생성할 수 없다. 히드라를 생성하려면 <em>히드라리스크 굴</em>이라는 <strong>또 다른 객체</strong>를 만들어 줘야 한다.</li>
    </ul>
  </li>
  <li>즉 <strong>하나의 풀 객체에서는 하나의 함수만 실행시킬 수 있다.</strong> 멀티프로세싱 프로세스가 각 프로세스 객체마다 다른 함수를 배치할 수 있는 것과 차이점이다.</li>
  <li>그럼 풀은 어쩔 때 유리하나. 눈치가 빠르면 알겠지만 <strong>같은 함수를 인자만 다르게 하여 여러 번 실행해야 할 때</strong> 프로세스보다 간단하게 멀티프로세싱을 사용할 수 있다.
    <ul>
      <li>풀 객체를 선언할 때 프로세서 개수를 설정하면 객체에 함수와 인자들을 할당했을 때 <strong>풀 객체는 각 프로세서들에게 인자 하나씩을 할당해주고, 프로세서가 그 인자를 받아 함수를 끝내면 남아있는 인자들 중 또 알아서 프로세서에게 할당</strong>해주는 원리이다.</li>
      <li>프로세스는 부화장 하나마다 일일이 저글링 생성 명령을 내린다 보면 되고, 풀은 부화장 전부를 부대지정 한 후-그럴 수는 없지만- 저글링 생성 명령을 한번에 하는 것으로 볼 수 있다.
        <h2 id="사용법과-예제">사용법과 예제</h2>
        <h3 id="기초-사용법">기초 사용법</h3>
      </li>
    </ul>
  </li>
  <li>백문이 불여일견. 우선 간단한 사용법을 알려주자면,
    <ul>
      <li>
        <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">multiprocessing</span> <span class="kn">import</span> <span class="n">Pool</span>
<span class="p">(</span><span class="n">변수명</span><span class="p">)</span> <span class="o">=</span> <span class="n">Pool</span><span class="p">(</span> <span class="p">(</span><span class="n">워커</span> <span class="n">개수</span><span class="p">)</span> <span class="p">)</span>
<span class="p">(</span><span class="n">변수명</span><span class="p">).</span><span class="nb">map</span><span class="p">(</span> <span class="p">(</span><span class="n">실행</span> <span class="n">함수</span><span class="p">)</span> <span class="p">,</span> <span class="p">(</span><span class="n">함수</span> <span class="n">인자</span> <span class="n">리스트</span><span class="p">)</span> <span class="p">)</span>
<span class="p">(</span><span class="n">변수명</span><span class="p">).</span><span class="n">close</span><span class="p">()</span>
<span class="p">(</span><span class="n">변수명</span><span class="p">).</span><span class="n">join</span><span class="p">()</span>
</code></pre></div>        </div>
      </li>
      <li>먼저 Pool() 객체를 선언해야 한다. (워커 개수)는 풀 객체에서 사용할 프로세서 개수를 의미한다.<br />
그냥 괄호 안에 입력해도 되고, processes=(개수) 이렇게 명시적으로 입력해도 된다. 입력하지 않으면 os.cpu_count() 값으로 자동 처리된다.</li>
      <li>(함수 인자 리스트)는 리스트 형태로 받아야 한다. 함수에 들어갈 인자들을 리스트 형태로 만들어서 넣어주자.
        <ul>
          <li>만일 인자가 두개 이상일 경우에는 .map() 대신 .starmap()을 사용해야 하고, 형식도 약간 바뀐다. 이에 관해서는 아래 실전 예제에서 설명하겠다.</li>
        </ul>
      </li>
      <li>pool.close()는 이 작업이 끝나면 풀 객체를 닫는다는 말이다. 이후 또다른 풀 객체를 생성했을 때 꼬일 수 있기 때문이다.
        <ul>
          <li>pool.terminate()라는 변종도 있다. 이는 작업이 끝났든 말든 풀 객체를 닫아버린다.</li>
        </ul>
      </li>
      <li>pool.join()은 프로세스 때와 마찬가지로 풀 객체가 닫히면 다음 줄로 넘어갈 수 있다는 말이다.
        <h3 id="간단한-예제">간단한 예제</h3>
      </li>
      <li>추가 예정…
        <h3 id="실전-예제">실전 예제</h3>
        <h2 id="마치며">마치며</h2>
        <p>이상이다.</p>
      </li>
    </ul>
  </li>
  <li>작성 예정 글
    <ul>
      <li>쓰레딩-thread</li>
      <li>비동기 처리-asyncio</li>
      <li>새로운 멀티프로세싱 방법-concurrent.futures</li>
    </ul>
  </li>
</ul>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1" role="doc-endnote">
      <p>멀티프로세싱의 프로세스(from multiprocessing import Process)와는 다르다. 이 글에서 말하는 프로세스는 특별히 언급하지 않는 이상 ‘CPU 코어’라 생각하면 된다. 그래도 구분하기 위해 ‘CPU 코어’는 ‘프로세서’라고 지칭하겠다. <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>
:ET