---
layout: post
title: 파이썬 멀티프로세싱 프로세스
tags : [kongji]
---

파이썬 멀티프로세싱 프로세스를 알아보자

## 배경 지식
현재 시판중인 프로세서들은 모두 멀티코어-프로세서라는, 하나의 프로세서 안에 여러 개의 미니 프로세서[^1]들이 들어가 있는 구조이다.

15여년 전 AMD 사가 프로세서 성능의 한계를 돌파하기 위해 두 개의 프로세서를 집어넣은 CPU를 개발한 것을 시작으로,  
현재는 4개면 적은 거고, 많게는 12개까지 배치한 프로세서들이 생겨나고 있다.  
이 프로세서는 일종의 소형화된 기존 프로세서이나,  
최근에는 ARM/인텔 사의 빅-리틀 시스템이나 엔비디아 사의 쿠다-텐서 코어 같이 특정 작업에 전문화된 프로세서를 여러 종류 놓는 시스템으로 발전하는 추세이다.

이야기가 삼천뽀로 가는거같으니 결론만 말하자면 __파이썬에서는 멀티 프로세싱이라는, 프로세스 내의 미니 프로세서들을 각각 사용할 수 있는 기능을 제공한다.__

## 멀티 프로세싱이란
멀티 프로세싱은 위에서도 말했듯이 미니 프로세서(앞으로는 《**코어**》라고 지칭하겠다.)를 모두 활용할 수 있도록 하는 기본 라이브러리이다.  
라이브러리명은 ***multiprocessing***이다.

해당 라이브러리는 *threading*이라는 라이브러리의 응용형으로, 2.6 버전에서 추가되었다.  
threading은 쉽게 말해서 하나의 프로세스 내에서 여러 작업을 동시에 수행하는 기능이다. threading에 관해서는 추후 설명하겠다.

보통 코드를 짜고 실행하면 해당 코드는 하나의 프로세스만을 사용한다.  
즉 본인 컴퓨터의 코어 수가 4개라면, 코드 실행시 3개의 코어는 논다는 말이다.[^2]

따라서 많은 일이 필요한 작업의 경우에는-예를 들면 백만개짜리 배열의 각 요소값을 1만큼 더하는-그냥 코드를 짜면 하나의 코어가 1부터 백만까지 다 할 것이다.  
그러나 4개의 코어를 모두 사용한다고 하면 4개의 코어가 25만개씩 나눠서 할 것이니, 시간이 ¼만큼 단축될 것이다!

그러면 이를 어떻게 하나? multiprocessing 라이브러리에서는 크게 두가지 방법을 제공하고 있다.
* Process
  * ```python
    from multiprocessing import Process
    ```

    로 불러온다.
* Pool
  * ```python
    from multiprocessing import Pool
    ```

    로 불러온다.
* Queue도 있지만, 본인은 다루지 않겠다.

## Process
* Process는 **함수를 실행**하는 독립된 프로세스이다.
  * 독립된 프로세스이기에 다른 프로세스 간 소통하지 않는다.
* ```python
  (변수명) = Process(target=(실행할 함수), args=(함수 인자))
  (변수명).start()
  (변수명).join()
  ```
  이렇게 실행한다.
* 인자를 놓는 args 값으로는 (인자1,인자2,...,) 이렇게 괄호 안에 인자들을 놓고 **괄호 마지막은 무조건 쉼표**로 끝나야 한다.
* start()는 프로세스를 시작(즉 함수 실행)한다는 말이다.
* join()은 프로세스가 끝날 때까지 기다린다는 말이다.
  * 만일 join()이 없으면 프로세스가 시작되어도 start() 다음 코드가 실행될 것이다.
  * 따라서 여러 프로세스를 동시에 사용할 것이면 **모든 프로세스를 먼저 start()해준 후 join()**을 해야 한다.

### 간단한 예제
어딜가나 다 있는...1부터 100 출력을 예제로 들어보자.  
0~99가 있는 배열을 만들어서 1씩 더한 후 출력하는 함수가 있다.  
배열을 25개 단위로 4개씩 쪼개 각 프로세스에다 할당한 후 실행해보자.
```python
from multiprocessing import Process

from time import time

tosso = [i for i in range(100)]

def duhagi(tissi):
    for i in tissi:
        i+=1
        print(i)

if __name__ == "__main__":

    a = time()

    p1 = Process(target=duhagi, args=(tosso[:25], ))
    p2 = Process(target=duhagi, args=(tosso[25:50], ))
    p3 = Process(target=duhagi, args=(tosso[50:75], ))
    p4 = Process(target=duhagi, args=(tosso[75:100], ))
    p1.start()
    p2.start()
    p3.start()
    p4.start()
    p1.join()
    p2.join()
    p3.join()
    p4.join()
    
    print("끝!")
    
    
    
```
실행 결과  

![py1-img1](/images/posts/python1-img1.png)

결과를 잘 보면 1부터 100까지 순차 출력되는게 아닌 뒤엉키는 것을 볼 수 있는데,  
이는 프로세스들의 **실행 순서가 고정된 것이 아니**기 때문이다.  
즉 무조건 p1->p2->p3 순이 아닌 p3->p1->p2 이런 식으로 실행될 수 있다는 것이다.  
위 코드를 계속 실행해 보면 출력 순서가 매번 바뀌는 것을 알 수 있을 것이다.

만일 위 코드에서 join()을 하지 않으면  

![py1-img2](/images/posts/python1-img2.png)

이렇게 《끝!》이 맨 앞에 나와버린다.  
위에서 말한 것처럼 프로세스가 끝날 때까지 기다리지 않고 start() 다음 코드, 즉 print("끝!") 코드를 실행해버리는 것이다.  
join()은 이 외에도 프로세스가 끝나면 종료해주는 기능이 있으니  
멀티프로세싱 작업 뒤에 또다른 작업이 있으면 join()을 해줘 자원 낭비를 줄이자.

### 응용 예제
다음은 본인이 모 프로젝트에서 사용한 멀티프로세싱 코드이다.  
보안 유지를 위해 일부 변수명 및 값들을 익명 처리했음에 유의하라.

```python
def dataupload(models):

    processes = []

    for model in models:
        url = f"CENSORED"
        if model == 1:
            my = a(model,url)

        elif model == 2:
            my = b(model,url)

        elif model == 3:
            my = c(model,url)

        elif model == 4:
            my = d(model,url)

        elif model == 5:
            my = e(model,url)

        elif model == 6:
            my = f(model,url)

        elif model == 7:
            my = g(model,url)

        elif model == 8:
            my = h(model,url)

        elif model == 9:
            my = i(model,url)
    
        processes.append(Process(target=my.autoupload))
    
    for process in processes:
        process.start()
    for process in processes:
        process.join()
```

해당 코드는 model 정보들이 담겨있는 models 배열을 인자로 받아
model 정보에 따라 model,url 속성을 갖는 클래스(a,b,c,...)를 생성하여
클래스의 autoupload 메소드를 실행하는 멀티프로세스를 만들어 실행하는 함수이다.  

즉 models가 [1,2,3,4]이면 a,b,c,d 클래스의 autoupload를 각각 수행하는 프로세스 4개가 동시 실행된다는 것이다.

쓰레딩 문서에서 다룰 예정이지만, multiprocessing은 〈여러 콘솔에서 파이썬 함수를 각각 실행하는 것에 가깝기 때문에〉 **경쟁 조건**이 일어나지 않는다.  
설사 프로세스들이 같은 변수를 인자로 갖는다 해도, 실제 함수에서 쓰는 변수는 해당 변수의 *복제품*이기 때문에 변수를 공유하는 것이 아니다.  
이를 정확하게 알기 위해서는 주소값, 얉은 복사, 깊은 복사,... 등등을 알아야 하기 때문에... 이것도 차근차근 다뤄보겠다.

## 마치며
이상이다.
* 작성 예정 글
  * 멀티프로세싱 풀
  * 쓰레딩

[^1]: 코어라고도 한다.
[^2]: 여기서 논다는 것은 '해당 코드에 작업을 할당받지 않는다는 것'을 의미한다.