---
layout: post
title: 알고리듬 문제를 풀어보자-dfs
tags : [algorithm]
---

dfs 알고리듬과 실전문제
<!--excerpt-->

## 시작하면서
이번에는 알고리듬 문제를 풀어보겠다.  
알고리듬은 프로그래머의 기본 중 기본이기 때문이다.  
비단 취업 준비뿐만이 아니라 회사 업무, 이직시에도 알고리듬 문제를 풀 줄 알아야 한다.  
회사 업무평가나 경력직 채용도 코딩 테스트를 보기 때문이다...

다행히 학생 시절 미친듯한 과제 폭탄으로 알고리듬이라면 치가 떨리기에  
알고리듬 포스트는 지금까지 학습한 내용을 상기시키고 문제를 풀어보며 응용하는 방식으로 써보려고 한다.

## dfs 알고리듬
dfs는 깊이-우선-탐색이라는 의미로 그래프 내 모든 노드를 돌 때 쓰이는 가장 기본적인 알고리듬이다.  
그래프가 뭐고, 노드가 뭐인지는 이제 설명하겠다.  

### 그래프
* **그래프**는 쉽게 말해 **점들이 선으로 연결된 집합**을 뜻한다.
  * 점을 **버텍스** 또는 **노드**
  * 선을 **엣지**라고 부른다.
* 먼저 점을 여러 개 찍는다. 그리고 점들을 선으로 연결한다. 연결되지 않는 점이 있어도 되고, 점 하나에 선을 몇 개든 연결할 수 있다. 자기 자신에도 선을 연결할 수 있다. 이렇게 하면 그래프 완성!
* 또한 엣지들에는 **방향**과 **가중치**라는 것이 존재할 수 있다.
  * 방향은 ·->· 이런 그래프가 있을 때 왼쪽 노드에서 오른쪽 노드로는 갈 수 있지만, 그 반대는 안된다.  
    물론 양방향 엣지도 존재 가능하다.
  * 가중치는 엣지에 수 등을 부여하여 이 엣지로 이동하면 이정도의 비용이 든다, 를 선언하는 것이다.  
    눈치 챘겠지만, 보통 시작과 끝 노드를 주고 *가장 적은 가중치로 이동하세요* 등에 사용된다.
* **그래프 탐색**은 **그래프 안의 버텍스들을 찾**는 알고리듬이다.
  * 크게 *모든 버텍스를 찾는* 알고리듬, 시작과 끝 버텍스를 주고 *둘 사이를 가장 적은 엣지로 찾아가는* 알고리듬이 존재한다.
  * 이게 무슨 쓸모가 있나 생각하기 쉽지만, 활용 범위는 무궁무진하다. 가장 대표적인 예로는 게임 분야를 들 수 있다.
    * GTA나 사이버펑크 같은 오픈-월드 게임에서는 도시의 생동감을 표현하기 위해 내비게이션 기능이 필요한데, 이 때 이러한 그래프 탐색 알고리듬이 활용되는 것이다.[^1]
    * dfs 알고리듬은 *미로 찾기*같이 경로를 일일이 찾아봐야 하는 경우에 주로 사용된다.

### 인접배열와 인접행렬
* dfs 알고리듬을 풀기 위해서는 **인접 배열**(인접 리스트)와 **인접 행렬**이라는 개념을 알아야 한다. 이 들은 *버텍스 간의 연결관계를 수학적으로 표현하는 방법*이다.
![algol1-img1](/images/posts/algorithm1-img1.png)  
이러한 그래프가 있다고 보자. 올림픽도 막 끝난 만큼 오륜기 모양으로 만들어봤다.  
동그라미는 버텍스(노드), 선은 양방향 엣지이다.
  * 1번 노드에는 4번 노드가, 2번 노드에는 4번 노드와 5번 노드가 연결되어 있다.  
  * 이렇게 각 노드마다 연결된 노드들을 *행렬로 표현*하면 인접 행렬, *배열로 표현*하면 인접 배열이다.
* 그럼 어떻게 표현할 것인가. 쉽게 생각하면 된다.
* **인접 행렬**
  * 행과 렬 개수가 각각 노드 개수인 행렬을 만든다.
  * 각 행과 렬을 노드 번호로 생각하고, 행 노드마다 연결된 노드 번호를 찾아 그 번호의 렬을 체크해주면 된다.
  * 그러면 위 그래프를 인접 행렬로 표현해보면  
    ![algol1-img3](/images/posts/algorithm1-img3.png)  
    이렇게 되겠지?
  * 참고로 자기 자신끼리는 체크하지 않는다. 즉 1열 1행, 2열 2행,... 등은  
    ![algol1-img2](/images/posts/algorithm1-img2.png)  
    굳이 이렇게 자기 스스로 연결되어 있지 않는 이상 체크 안한다.
* **인접 배열**
  * 인접 행렬은 위 그림처럼 *2차원*적으로 표현하지만, 인접 배열은 *1차원*으로 표현한다.
  * 무슨 말이냐면...
    1. 먼저 요소 개수가 노드 개수인 빈 리스트를 만든다.
    ```C++
    int injop = new int[5]
    ```
    2. 각 요소의 인덱스는 노드 번호라고 생각한다.
    ```C++
    injop = [1번,2번,3번,4번,5번]
    ```
    3. 각 요소의 값은 해당하는 노드 번호에 연결된 노드 번호 리스트이다.
    ```C++
    injop = [[4],[4,5],[5],[2,5],[2,3]]
    ```

### dfs의 기본원리
* 이제 모든 사전준비가 끝났다. 드디어 dfs가 뭔지를 알 수 있다.
* dfs를 푸는 방법은...
    1. 우선 **시작 노드**를 정한다.
    2. 시작 노드에서 

[^1]: 이런 복잡한 게임에서는 더 고도화된 방식인 *최단 거리 탐색*을 사용한다. 벨만-포드 알고리듬, 플로이드-와셔 알고리듬 등 여러 방식이 있는데, 시간 나면 설명하겠다.