---
layout: post
title: 쿠버네티스 MSA 서비스 만들기
categories: [devops]
tags: [springboot, jenkins, kubernetes, apachekafka, mysql]
excerpt: 젠킨스와 쿠버네티스로 MSA 환경만들기
---

## 개요

지난 1주 동안 부트캠프에서 미니 프로젝트를 진행하였다. 매일 10시까지 있었던건 안비밀

본인 조는 일종의 게시판 서비스를 만들었는데... 본인은 게이트웨이와 사용자(user) 마이크로서비스를 담당하였다.

![do1-img1](/images/posts/devops1-img1.png)  
![do1-img2](/images/posts/devops1-img2.png)

구성도는 위와 같다.

각 마이크로서비스(gateway, user, post, leaderboard)가 서로의 db를 가지고,  
kafka를 통해 통신하는 구조였다. 당연히 각각은 docker로 컨테이너 구현되어 있고.

발표 때는 시간과 여백이 부족하여 로컬 환경에서 구동했는데, 프로젝트가 끝났지만 뭔가 오기? 가 생겨 주말 동안 젠킨스 배포 시스템과 쿠버네티스 구현을 해보기로 했다.

## 젠킨스 만들기

### 젠킨스 초기설정

우선 젠킨스를 설치해야 하니 컨테이너로 만들고...
```yaml
version: "3"
services:
  jenkins:
    image: jenkins/jenkins:lts
    container_name: jenkins
    restart: always
    user: root
    volumes:
      - ./jenkins_home:/var/jenkins_home
      - /var/run/docker.sock:/var/run/docker.sock
    ports:
      - 8000:8080
    environment:
      - DOCKER_HOST=unix:///var/run/docker.sock 
```

```docker-compose up -d``` 로 실행시켜줬다. 포트는 8000 포트를 사용할 예정~  
(```ports: -8000:8080``` 의 의미는 컨테이너 안에는 8080 포트로 실행하는데 밖에서는 8000으로 접속한다는 것을 의미한다. 즉 일종의 프록싱)

![do1-img3](/images/posts/devops1-img3.png)

젠킨스를 처음 들어가면 초기 비밀번호가 필요할건데, 화면에도 나오지만  
```/var/jenkins_home/secrets/initialAdminPassword``` 여기 있다고 한다.  

컨테이너에 직접 접속해서 찾으면 된다.  

![do1-img4](/images/posts/devops1-img4.png)

```bash
docker exec -it (내 젠킨스 컨테이너이름) /bin/bash
cat /var/jenkins_home/secrets/initialAdminPassword
```

여차저차 초기셋팅을 끝내고,




### 젠킨스파일 만들기

각 서비스별로 젠킨스파일을 만들어 준다.  
본 프로젝트는 spring boot로 마이크로서비스들이 구현되어 있으니 아래와 같이 작성~

```
#!/usr/bin/env groovy
def APP_NAME
def APP_VERSION
def DOCKER_IMAGE_NAME
def PROD_BUILD = false
def TAG_BUILD = false
pipeline {
    agent {
        node {
            label 'master'
        }
    }

    parameters {
        gitParameter branch: '',
                    branchFilter: '.*',
                    defaultValue: 'origin/(메인브랜취 이름)',
                    description: '', listSize: '0',
                    name: 'TAG',
                    quickFilterEnabled: false,
                    selectedValue: 'DEFAULT',
                    sortMode: 'DESCENDING_SMART',
                    tagFilter: '*',
                    type: 'PT_BRANCH_TAG'

        booleanParam defaultValue: false, description: '', name: 'RELEASE'
    }

    environment {
        GIT_URL = "(서비스 깃허브 주소)"
        GITHUB_CREDENTIAL = "github-token"
        ARTIFACTS = "build/libs/**"
        DOCKER_REGISTRY = "(내 이름)"
        DOCKERHUB_CREDENTIAL = 'dockerhub-token'
    }

    options {
        disableConcurrentBuilds()
        buildDiscarder(logRotator(numToKeepStr: "30", artifactNumToKeepStr: "30"))
        timeout(time: 120, unit: 'MINUTES')
    }

    tools {
        gradle 'Gradle 8.14.2'
        jdk 'OpenJDK 17'
        dockerTool 'Docker'
    }

    stages {
        stage('Set Version') {
            steps {
                script {
                    APP_NAME = sh (
                            script: "gradle -q getAppName",
                            returnStdout: true
                    ).trim()
                    APP_VERSION = sh (
                            script: "gradle -q getAppVersion",
                            returnStdout: true
                    ).trim()

                    DOCKER_IMAGE_NAME = "${DOCKER_REGISTRY}/${APP_NAME}:${APP_VERSION}"

                    sh "echo IMAGE_NAME is ${APP_NAME}"
                    sh "echo IMAGE_VERSION is ${APP_VERSION}"
                    sh "echo DOCKER_IMAGE_NAME is ${DOCKER_IMAGE_NAME}"

                    sh "echo TAG is ${params.TAG}"
                    if( params.TAG.startsWith('origin') == false && params.TAG.endsWith('/main') == false ) {
                        if( params.RELEASE == true ) {
                            DOCKER_IMAGE_NAME += '-RELEASE'
                            PROD_BUILD = true
                        } else {
                            DOCKER_IMAGE_NAME += '-TAG'
                            TAG_BUILD = true
                        }
                    }
                }
            }
        }

        stage('Build & Test Application') {
            steps {
                sh "gradle clean build"
            }
        }

        stage('Build Docker Image') {
//             when {
//                 expression { PROD_BUILD == true || TAG_BUILD == true }
//             }
            steps {
                script {
                    docker.build "${DOCKER_IMAGE_NAME}"
                }
            }
        }

        stage('Push Docker Image') {
//             when {
//                 expression { PROD_BUILD == true || TAG_BUILD == true }
//             }
            steps {
                script {
                    docker.withRegistry("", DOCKERHUB_CREDENTIAL) {
                        docker.image("${DOCKER_IMAGE_NAME}").push()
                    }

                    sh "docker rmi ${DOCKER_IMAGE_NAME}"
                }
            }
        }
    }
}
```